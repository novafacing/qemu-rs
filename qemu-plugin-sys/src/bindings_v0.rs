/* automatically generated by rust-bindgen 0.72.0 */

pub const QEMU_PLUGIN_VERSION: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct GArray {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_uint,
}
impl Default for GArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct GByteArray {
    pub data: *mut ::std::os::raw::c_uchar,
    pub len: ::std::os::raw::c_uint,
}
impl Default for GByteArray {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type qemu_plugin_id_t = u64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qemu_info_t {
    #[doc = " string describing architecture"]
    pub target_name: *const ::std::os::raw::c_char,
    pub version: qemu_info_t__bindgen_ty_1,
    #[doc = " is this a full system emulation?"]
    pub system_emulation: bool,
    pub __bindgen_anon_1: qemu_info_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct qemu_info_t__bindgen_ty_1 {
    pub min: ::std::os::raw::c_int,
    pub cur: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qemu_info_t__bindgen_ty_2 {
    pub system: qemu_info_t__bindgen_ty_2__bindgen_ty_1,
}
#[doc = " smp_vcpus may change if vCPUs can be hot-plugged, max_vcpus\n is the system-wide limit."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct qemu_info_t__bindgen_ty_2__bindgen_ty_1 {
    pub smp_vcpus: ::std::os::raw::c_int,
    pub max_vcpus: ::std::os::raw::c_int,
}
impl Default for qemu_info_t__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for qemu_info_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Prototypes for the various callback styles we will be registering\n in the following functions."]
pub type qemu_plugin_simple_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t)>;
pub type qemu_plugin_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, userdata: *mut ::std::os::raw::c_void),
>;
pub type qemu_plugin_vcpu_simple_cb_t = ::std::option::Option<
    unsafe extern "C" fn(id: qemu_plugin_id_t, vcpu_index: ::std::os::raw::c_uint),
>;
pub type qemu_plugin_vcpu_udata_cb_t = ::std::option::Option<
    unsafe extern "C" fn(vcpu_index: ::std::os::raw::c_uint, userdata: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    #[doc = " qemu_plugin_uninstall() - Uninstall a plugin\n @id: this plugin's opaque ID\n @cb: callback to be called once the plugin has been removed\n\n Do NOT assume that the plugin has been uninstalled once this function\n returns. Plugins are uninstalled asynchronously, and therefore the given\n plugin receives callbacks until @cb is called.\n\n Note: Calling this function from qemu_plugin_install() is a bug."]
    pub fn qemu_plugin_uninstall(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    #[doc = " qemu_plugin_reset() - Reset a plugin\n @id: this plugin's opaque ID\n @cb: callback to be called once the plugin has been reset\n\n Unregisters all callbacks for the plugin given by @id.\n\n Do NOT assume that the plugin has been reset once this function returns.\n Plugins are reset asynchronously, and therefore the given plugin receives\n callbacks until @cb is called."]
    pub fn qemu_plugin_reset(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_init_cb() - register a vCPU initialization callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU is initialized.\n\n See also: qemu_plugin_register_vcpu_exit_cb()"]
    pub fn qemu_plugin_register_vcpu_init_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_exit_cb() - register a vCPU exit callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU exits.\n\n See also: qemu_plugin_register_vcpu_init_cb()"]
    pub fn qemu_plugin_register_vcpu_exit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_idle_cb() - register a vCPU idle callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU idles."]
    pub fn qemu_plugin_register_vcpu_idle_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_resume_cb() - register a vCPU resume callback\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a vCPU resumes execution."]
    pub fn qemu_plugin_register_vcpu_resume_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_simple_cb_t,
    );
}
#[doc = " Opaque types that the plugin is given during the translation and\n instrumentation phase."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_tb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_insn {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum qemu_plugin_cb_flags {
    #[doc = " callback does not access the CPU's regs"]
    QEMU_PLUGIN_CB_NO_REGS = 0,
    #[doc = " callback reads the CPU's regs"]
    QEMU_PLUGIN_CB_R_REGS = 1,
    #[doc = " callback reads and writes the CPU's regs"]
    QEMU_PLUGIN_CB_RW_REGS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum qemu_plugin_mem_rw {
    QEMU_PLUGIN_MEM_R = 1,
    QEMU_PLUGIN_MEM_W = 2,
    QEMU_PLUGIN_MEM_RW = 3,
}
#[doc = " qemu_plugin_register_vcpu_tb_trans_cb() - register a translate cb\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called every time a translation occurs. The @cb\n function is passed an opaque qemu_plugin_type which it can query\n for additional information including the list of translated\n instructions. At this point the plugin can register further\n callbacks to be triggered when the block or individual instruction\n executes."]
pub type qemu_plugin_vcpu_tb_trans_cb_t =
    ::std::option::Option<unsafe extern "C" fn(id: qemu_plugin_id_t, tb: *mut qemu_plugin_tb)>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_tb_trans_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_tb_trans_cb_t,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_tb_trans_exec_cb() - register execution callback\n @tb: the opaque qemu_plugin_tb handle for the translation\n @cb: callback function\n @flags: does the plugin read or write the CPU's registers?\n @userdata: any plugin data to pass to the @cb?\n\n The @cb function is called every time a translated unit executes."]
    pub fn qemu_plugin_register_vcpu_tb_exec_cb(
        tb: *mut qemu_plugin_tb,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum qemu_plugin_op {
    QEMU_PLUGIN_INLINE_ADD_U64 = 0,
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_tb_trans_exec_inline() - execution inline op\n @tb: the opaque qemu_plugin_tb handle for the translation\n @op: the type of qemu_plugin_op (e.g. ADD_U64)\n @ptr: the target memory location for the op\n @imm: the op data (e.g. 1)\n\n Insert an inline op to every time a translated unit executes.\n Useful if you just want to increment a single counter somewhere in\n memory."]
    pub fn qemu_plugin_register_vcpu_tb_exec_inline(
        tb: *mut qemu_plugin_tb,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_insn_exec_cb() - register insn execution cb\n @insn: the opaque qemu_plugin_insn handle for an instruction\n @cb: callback function\n @flags: does the plugin read or write the CPU's registers?\n @userdata: any plugin data to pass to the @cb?\n\n The @cb function is called every time an instruction is executed"]
    pub fn qemu_plugin_register_vcpu_insn_exec_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_udata_cb_t,
        flags: qemu_plugin_cb_flags,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_register_vcpu_insn_exec_inline() - insn execution inline op\n @insn: the opaque qemu_plugin_insn handle for an instruction\n @cb: callback function\n @op: the type of qemu_plugin_op (e.g. ADD_U64)\n @ptr: the target memory location for the op\n @imm: the op data (e.g. 1)\n\n Insert an inline op to every time an instruction executes. Useful\n if you just want to increment a single counter somewhere in memory."]
    pub fn qemu_plugin_register_vcpu_insn_exec_inline(
        insn: *mut qemu_plugin_insn,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
unsafe extern "C" {
    #[doc = " Helpers to query information about the instructions in a block"]
    pub fn qemu_plugin_tb_n_insns(tb: *const qemu_plugin_tb) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_vaddr(tb: *const qemu_plugin_tb) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_tb_get_insn(tb: *const qemu_plugin_tb, idx: usize) -> *mut qemu_plugin_insn;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_data(insn: *const qemu_plugin_insn) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_size(insn: *const qemu_plugin_insn) -> usize;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_vaddr(insn: *const qemu_plugin_insn) -> u64;
}
unsafe extern "C" {
    pub fn qemu_plugin_insn_haddr(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_void;
}
#[doc = " Memory Instrumentation\n\n The anonymous qemu_plugin_meminfo_t and qemu_plugin_hwaddr types\n can be used in queries to QEMU to get more information about a\n given memory access."]
pub type qemu_plugin_meminfo_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct qemu_plugin_hwaddr {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " meminfo queries"]
    pub fn qemu_plugin_mem_size_shift(info: qemu_plugin_meminfo_t) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_sign_extended(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_big_endian(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_mem_is_store(info: qemu_plugin_meminfo_t) -> bool;
}
unsafe extern "C" {
    #[doc = " qemu_plugin_get_hwaddr():\n @vaddr: the virtual address of the memory operation\n\n For system emulation returns a qemu_plugin_hwaddr handle to query\n details about the actual physical address backing the virtual\n address. For linux-user guests it just returns NULL.\n\n This handle is *only* valid for the duration of the callback. Any\n information about the handle should be recovered before the\n callback returns."]
    pub fn qemu_plugin_get_hwaddr(
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
    ) -> *mut qemu_plugin_hwaddr;
}
unsafe extern "C" {
    #[doc = " The following additional queries can be run on the hwaddr structure\n to return information about it. For non-IO accesses the device\n offset will be into the appropriate block of RAM."]
    pub fn qemu_plugin_hwaddr_is_io(hwaddr: *mut qemu_plugin_hwaddr) -> bool;
}
unsafe extern "C" {
    pub fn qemu_plugin_hwaddr_device_offset(haddr: *const qemu_plugin_hwaddr) -> u64;
}
pub type qemu_plugin_vcpu_mem_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        vcpu_index: ::std::os::raw::c_uint,
        info: qemu_plugin_meminfo_t,
        vaddr: u64,
        userdata: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_mem_cb(
        insn: *mut qemu_plugin_insn,
        cb: qemu_plugin_vcpu_mem_cb_t,
        flags: qemu_plugin_cb_flags,
        rw: qemu_plugin_mem_rw,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_mem_inline(
        insn: *mut qemu_plugin_insn,
        rw: qemu_plugin_mem_rw,
        op: qemu_plugin_op,
        ptr: *mut ::std::os::raw::c_void,
        imm: u64,
    );
}
pub type qemu_plugin_vcpu_syscall_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_index: ::std::os::raw::c_uint,
        num: i64,
        a1: u64,
        a2: u64,
        a3: u64,
        a4: u64,
        a5: u64,
        a6: u64,
        a7: u64,
        a8: u64,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_cb_t,
    );
}
pub type qemu_plugin_vcpu_syscall_ret_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        id: qemu_plugin_id_t,
        vcpu_idx: ::std::os::raw::c_uint,
        num: i64,
        ret: i64,
    ),
>;
unsafe extern "C" {
    pub fn qemu_plugin_register_vcpu_syscall_ret_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_vcpu_syscall_ret_cb_t,
    );
}
unsafe extern "C" {
    #[doc = " qemu_plugin_insn_disas() - return disassembly string for instruction\n @insn: instruction reference\n\n Returns an allocated string containing the disassembly"]
    pub fn qemu_plugin_insn_disas(insn: *const qemu_plugin_insn) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " qemu_plugin_vcpu_for_each() - iterate over the existing vCPU\n @id: plugin ID\n @cb: callback function\n\n The @cb function is called once for each existing vCPU.\n\n See also: qemu_plugin_register_vcpu_init_cb()"]
    pub fn qemu_plugin_vcpu_for_each(id: qemu_plugin_id_t, cb: qemu_plugin_vcpu_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_register_flush_cb(id: qemu_plugin_id_t, cb: qemu_plugin_simple_cb_t);
}
unsafe extern "C" {
    pub fn qemu_plugin_register_atexit_cb(
        id: qemu_plugin_id_t,
        cb: qemu_plugin_udata_cb_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " returns -1 in user-mode"]
    pub fn qemu_plugin_n_vcpus() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " returns -1 in user-mode"]
    pub fn qemu_plugin_n_max_vcpus() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " qemu_plugin_outs() - output string via QEMU's logging system\n @string: a string"]
    pub fn qemu_plugin_outs(string: *const ::std::os::raw::c_char);
}
